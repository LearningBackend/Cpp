Змінну і можна ініціалізувати не тільки в скобках цикла for:

тобто ми можемо зробити те, що я написав вище,(АЛЕ БЛЯТЬ, КРАПКА З КОМОЮ ПОВИННА СТОЯТИ, ТОМУ ЩО КОМПІЛЯТОР ПОШЛЕ НАХУЙ ТЕБЕ)

short i = 0;
	for (; i < 10; i++)
	{
		cout << "змінна і = " << i << endl;
	}

for (*;* i < 10; i++) - має стояти там на початку виділив 
символом *
//////////////////////////////////////
Отже, використовувати цю фічу можна так.

short i = 0;
	for (; i < 10; i++)
	{
		cout << "змінна і = " << i << endl;
	}

	
	for (; i < 10; i++)
	{
		cout << "змінна і = " << i << endl;
	}

значить у нас є 2 цикл for, де також потрібно використовувати змінну і, тому зручно винести з цикла її (тому що в самом циклі вона буде не доступна іншому циклу).
/////////////////////////
short i = 0;

	cout << "1й цикл" << endl;

	for (; i < 10; i++)
	{
		cout << "змінна і = " << i << endl;
	}

	cout << "2й цикл" << endl;
	for (; i < 20; i++)
	{
		cout << "змінна і = " << i << endl;
	}

в цьому коді ми виводимо спочатку з першого циклу від 0 до 10(в консоль виведе від 0 до 9), потім в 2 циклі ми так само виведемо до 20 але вже з 10, тому що і вже буде перед 2 циклом дорівнювати 9
//////////////////////////////////////////

for (short i = 0; i < 10;)
	{
		cout << "змінна і = " << i << endl;
		i++;
	}
тут ми спочатку виводим початкове значення змінної, а потім додаємо до неї +1

for (short i = 0; i < 10;)
	{
           i++;		
           cout << "змінна і = " << i << endl;
	}

а тут навпаки, спочатку додається +1, а потім виводиться значення і
//////////////////////////////////////

також всі значення в циклі не обовязкові для роботи його, але крапка з комою повинна бути присутньою(точніше дві)*
for (; ; ) 
	{
		//cout << "змінна і = " << i << endl;
		cout << "a" << endl;
	}

for (; ; ) <---- ось так*
тут буде постійно виводитись значення а, тому що виходу з циклу у нас немає

//////////////////////////////////////////////////

for (int i = 0, j = 10; i < 10 && j!=5; i++, j--)
	{
		cout << "змінні і = " << i << endl;
		cout << "змінні j = " << j << endl;
	}

тут в нас і збільшується до 10 і j зменшується до моменту поки не буде дорівнювати 5, тобто до 6, && - це в нас була умова і(не зміної), тобто умова була що і буде збільшуватися до 10 та j не має дорівнювати 5, як тільки умова j видала false, ми вишли з циклу